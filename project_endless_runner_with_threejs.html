<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" rel="stylesheet" />
  <title>Endless Runner with Three.js</title>
  <style>
     @import url('https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&display=swap');

    /* Setup */

    *{
      padding: 0;
      margin: 0;
      box-sizing: border-box;
    }

    :root{
      --font-normal: "DM Sans", sans-serif;
      --font-fancy: Palatino Linotype;
      --font-header: medium-content-sans-serif-font, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;

      --project-gray: gray;
      --project-white: white;

      --display-blue: #2f1664;
      --display-hover-blue: #6942bb;
      --display-font-color: #FFFFFF;
    }

    /* Header */

    nav{
      margin-top: 6vh;

      width: 100%;
      height: 6vh;

      display: flex;
      row-gap: 3vh;
      flex-direction: row;

      font-family: var(--font-normal);

    }

    nav a, footer a{
      text-decoration: none;
      color: rgb(85, 26, 139);
    }

    .left-text{

      flex-grow: 3;
      padding-left: 4rem;
      display: flex;
      align-items: center;

      font-weight: 400;
      font-size: 25px;
    }

    .logo-img{
      width: 1em;
      aspect-ratio: 1 /1;
      margin-right: 0.5rem;
    }

    .right-text{
      flex-grow: 1;
      display: flex;
      justify-content: end;
      align-items: center;

      padding-right: 3.5rem;
      column-gap: 2.5rem;

    }


    @media (width < 768px) {

      nav{
        flex-direction: column;
      }

      .left-text{
        justify-content: center;
        padding-inline: 0;

      }

      .right-text{
        justify-content: center;
        padding-inline: 0;
      }
    }

    @media (width < 426px) {
      .left-text{
        font-size: 4.7vw;
      }

      .right-text{
        font-size: 3.5vw;
      }
    }

    /* Footer */

    footer{
      font-size: 25px;
      font-family: var(--font-normal);

      padding-block: 1rem;
      padding-inline: 0.5rem;

      display: flex;
      flex-direction: row;

      position: relative;
      z-index: 2;

      background-color: #f1f5f9;
    } 

    @media (width < 768px) {
      footer{
        flex-direction: column;
        row-gap: 1rem;
      }
    }
    
    .section-wrapper{
      flex-grow: 1;

      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .section-wrapper .links{
      display: flex;
      column-gap: 1.3rem;

      font-size: 1rem;
    }

    @media (width < 376px) {
      .section-wrapper .section-name{
        font-size: 22px;
      }

      .section-wrapper .links{
        font-size: 3.8vw;
      }
    }

    /* Content */

    main{
      min-height: 100vh;
      width: 60vw;
      margin-inline:auto;
      margin-bottom: 2rem;
      /* border: 3px red solid; */

      display: flex;
      align-items: center;
      /* justify-content: center; */
      flex-direction: column;
      gap: 2vw;
    }

    .title-header{
      font-size: 3vw;
    }

    .title-header + img{
      margin-bottom: 2rem;
    }

    /* main > *{
      border: 3px orange solid;
    }

    main > * > * {
      border: 3px orchid solid;
    } */

    h1{
      font-family: var(--font-header);
      font-size: 24px;
    }

    main img{
      width: 100%;
      border: 1px black solid;
    }

    .map-display{
      filter: contrast(90%);
    }


    main > section{
      width: 80%;
    }

    section > p {
      margin-top: 1rem;
      font-size: 20px;
      font-family: var(--font-normal);
    }

    section > h1 + img{
      margin-top: 1rem;
    }

    pre{
      background-color: lightgray;
      display: flex;
      justify-content: start;
      align-items: center;
    }

    pre > code{
      margin-left: -3rem;
    }

    @media (width <= 768px) {
      main{
        width: 70vw;
        margin-top: 6vh;
      }
    }

    @media (width < 426px) {
      main{
        width: 100vw;
        font-size: 12px;
      }

      .title-header{
        font-size: 5vw;
      }

      h1{
      font-size: 4.5vw;
      }

      section > p {
      font-size: 16px;
     }
    }


  </style>
</head>
<body>
  <nav>
    <div class="left-text">
      <a href="index.html">
        <img src="Images/address-icon.svg" alt="" class="logo-img">
        Ying Ray
      </a>
    </div>

    <div class="right-text">
      <a href="index.html">Home</a>
      <a href="projects.html">Projects</a>
      <a href="about_me.html">About me</a>
      <a href="">Resume</a>
    </div>
  </nav>

  <main>
    <h1 class="title-header">Endless Runner with Three.js</h1>
    <img src="Images/threejs-runner-example-gif.gif" alt="">

    <section>
      <h1>Project Overview</h1>
      <p>Inspired by games such as Subway surfers and Temple Run, I decided to make a browser-based endless runner game, built with Three.js. The ultimate goal of this project was to familiarise myself with the capabilities of Three.js.</p>
    </section>

    <section>
      <h1>What is an Endless Runner?</h1>
      <img src="https://i.giphy.com/Fr5LA2RCQbnVp74CxH.webp" alt="">
      <p>Endless runner or infinite runner is a subgenre of platform game in which the player character runs for an infinite amount of time while avoiding obstacles. The player's objective is to reach a high score by surviving for as long as possible. As mentioned, Subway surfers and Temple Run are two popular examples of this subgenre.</p>
    </section>

    <section>
      <h1>What is Three.js?</h1>
      <img src="Images/threejs_logo.webp" alt="">
      <p>Three.js is a cross-browser JavaScript library and application programming interface used to create and display animated 3D computer graphics in a web browser using WebGL. In other words, it allows developers to display 3D objects on web pages with ease. <br><br>In this project, I will be using Three.js to build my endless runner game with 3D shapes. Lets now dive into the code for the project.</p>
    </section>

    <section>
      <h1>1. Import Three.js</h1>

      <pre>
        <code class="language-javascript">
          import * as THREE from 'three'
          import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
        </code>
      </pre>

      <p>Along with vanilla Three.JS, I will also be using the Orbit Controls Add-on, which allows users to move the camera in a free and intuitive manner.</p>
    </section>

    <section>
      <h1>2. Setup</h1>

      <pre>
        <code class="language-javascript">
          const scene = new THREE.Scene()
        </code>
      </pre>

      <p>To start, we must first create a Scene, using <code class="language-javascript">THREE.Scene()</code>. A Scene allows you to setup what and where objects is to be rendered by Three.js.</p>
  
      <pre>
        <code class="language-javascript">
          const camera = new THREE.PerspectiveCamera(
            85,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          camera.position.set(0, 6, 12);
        </code>
      </pre>

      <p>Moving on, the camera must then be setup. We will define a Perspective Camera, using <code class="language-javascript">THREE.PerspectiveCamera()</code>. This simulates a real-world camera, giving a perspective view (objects farther away appear smaller).</p>
  
      <pre>
        <code class="language-javascript">
          const renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true
          });
          renderer.shadowMap.enabled = true;
          renderer.setSize(window.innerWidth, window.innerHeight);
          document.body.appendChild(renderer.domElement);          
        </code>
      </pre>

      <p>This creates the WEBGL renderer, which is a 3D graphics API that runs in the browser. As such, <code class="language-javascript">THREE.WebGLRenderer()</code> is responsible for rendering the scene from the camera’s perspective and displaying it on the screen. <br><br>Now, with all the setup out of the way, we can finally focus on creating the game itself.</p>
    </section>

    <section>
      <h1>3. Creating and Positioning a Directional Light</h1>

      <pre>
        <code class="language-javascript">
          const light = new THREE.DirectionalLight(0xffffff, 1);
          light.position.y = 4;
          light.position.z = 1;
          light.castShadow = true;
          scene.add(light);          
        </code>
      </pre>

      <p>We must also add lighting in our scene, as without it, no objects can be seen. <code class="language-js">THREE.DirectionalLight()</code>simulates light coming from a specific direction, like a floodlight.</p>
    </section>

    <section>
      <h1>4. Defining the Game Environment</h1>

      <pre>
        <code class="language-javascript">
          class Box extends THREE.Mesh {
            constructor(
              { 
                width, 
                height, 
                depth, 
                color = '#00ff00', 
                velocity = { x: 0, y: 0, z: 0},
                position = { x: 0, y: 0, z: 0},
                zAcceleration = false,
              }
            ) 
          {          
        </code>
      </pre>

      <p>Since all entities in the game are rectangular in nature, I decided to use a class to define their geometries. <br><br>The Class Box extends <code class="language-javascript">THREE.Mesh</code>, meaning it inherits all the properties and methods of <code class="language-javascript">THREE.Mesh</code>, which is the base class for 3D objects in Three.js. Object properties such as dimensions, colour, and velocity are defined here.</p>
    
      <pre>
        <code class="language-javascript">
          super(
            new THREE.BoxGeometry(width, height, depth), 
            new THREE.MeshStandardMaterial({ color })
          )
        </code>
      </pre>

      <p>This creates a mesh, which is specified to have a <code class="language-js">BoxGeometry</code>, and using the <code class="language-js">MeshStandardMaterial</code>. The dimensions and colours will be provided later.</p>
  
      <pre>
        <code class="language-javascript">
          this.width = width
          this.height = height
          this.depth = depth
      
          this.position.set(position.x, position.y, position.z)
          
          this.updateSides()

          this.velocity = velocity
          this.gravity = 0.01
          this.zAcceleration = zAcceleration
        </code>
      </pre>

      <p>The width, height, and depth properties of the box are stored in the instance for later use, for collision detection. The velocity of the box, as well as the gravity, are also stored here. <br><br>Additionally, the <code class="language-javascript">updateSides()</code> method calculates and updates the positions of the box's sides, to facilitate collision detection. The code in <code class="language-javascript">updateSides()</code> will be discussed next.</p>

      <pre>
        <code class="language-javascript">
          updateSides() {
            this.top = this.position.y + this.height / 2
            this.bottom = this.position.y - this.height / 2
        
            this.right = this.position.x + this.width / 2
            this.left = this.position.x - this.width / 2 
        
            this.front = this.position.z + this.depth / 2
            this.back = this.position.z - this.depth / 2
          }        
        </code>
      </pre>

      <p><code class="language-javascript">updateSides()</code> calculates and updates the box’s boundaries in the 3D space based on its current position. This will be useful when detecting collisions with other objects.</p>

      <pre>
        <code class="language-javascript">
          update(ground) {
            this.updateSides()
        
            if (this.zAcceleration) this.velocity.z += 0.006
        
            this.position.x += this.velocity.x 
            this.position.z += this.velocity.z
        
            this.applyGravity(ground)
          }         
        </code>
      </pre>

      <p>The <code class="language-javascript">update()</code> method handles physics-related logic with <code class="language-javascript">updateSides()</code>, and updates the box's position.</p>

      <pre>
        <code class="language-javascript">
            applyGravity(ground, player) {
              this.velocity.y -= this.gravity
          
              if (boxCollision({
                box1: this,
                box2: ground
              })) {
                this.velocity.y *= 0.2 // Reduces bounce height
                this.velocity.y = -this.velocity.y // Inverts velocity for bounce
                
                if (this === cube) {
                  isTouchingGround = true
                }
              } else {
                this.position.y += this.velocity.y 
          
                if (this === cube) {
                  isTouchingGround = false
                }        
              }
            }
             
            function boxCollision ({box1, box2}) {
              const xCollision = box1.right >= box2.left && box1.left <= box2.right
              const yCollision = box1.bottom + box1.velocity.y <= box2.top && box1.top >= box2.bottom
              const zCollision = box1.front >= box2.back && box1.back <= box2.front
          
              return xCollision && yCollision && zCollision
            }

        </code>
      </pre>



      <p><code class="language-javascript">applyGravity()</code>handles the gravity related logic. For example, it decreases the box's Y-velocity to simulate the effect of gravity (<code class="language-javascript">this.velocity.y -= this.gravity</code>). <br><br>The funciton <code class="language-js">boxCollision()</code> checks if two boxes collide by checking if they overlap in the X, Y, and Z dimensions, which is used between the player's box and an enemy box. Additionally, if the box collides with the ground, <code class="language-js">boxCollision()</code> inverts the Y-velocity to simulate a bounce, and reduces the velocity by 80% (<code class="language-js">this.velocity.y *= 0.2</code>) to make each bounce smaller. <br><br><code class="language-js">applyGravity()</code> also checks if the player's cube is touching the ground, which is used to allow jumping later on in the code.</p>

      <pre>
        <code class="language-javascript">
          class Box extends THREE.Mesh {  
            constructor(
            { width, 
              height, 
              depth, 
              color = '#00ff00', 
              velocity = { x: 0, y: 0, z: 0},
              position = { x: 0, y: 0, z: 0},
              zAcceleration = false,
            }
            ) {
              super(
                new THREE.BoxGeometry(width, height, depth), 
                new THREE.MeshStandardMaterial({ color})
              )
        
              this.width = width
              this.height = height
              this.depth = depth
        
              this.position.set(position.x, position.y, position.z)
              
              this.updateSides()
        
              this.velocity = velocity
              this.gravity = 0.01
        
              this.zAcceleration = zAcceleration
            }
        
            updateSides() {
              this.top = this.position.y + this.height / 2
              this.bottom = this.position.y - this.height / 2
        
              this.right = this.position.x + this.width / 2
              this.left = this.position.x - this.width / 2 
        
              this.front = this.position.z + this.depth / 2
              this.back = this.position.z - this.depth / 2
            }
        
        
            update(ground) {
              this.updateSides()
        
              if (this.zAcceleration) this.velocity.z += 0.006
        
              this.position.x += this.velocity.x 
              this.position.z += this.velocity.z
        
              this.applyGravity(ground)
            }
        
            applyGravity(ground, player) {
              this.velocity.y -= this.gravity
        
              if (boxCollision({
                box1: this,
                box2: ground
              })) {
                this.velocity.y *= 0.2 //reduces the height of every consecutive bounce
                this.velocity.y = -this.velocity.y //inverts the velocity so as the bounce the object back up
                
                if (this === cube) {
                  isTouchingGround = true
                }
              }
        
              else {
                this.position.y += this.velocity.y 
        
                if (this === cube) {
                  isTouchingGround = false
                }        
              }
            }
          }

          function boxCollision ({box1, box2}) {
            const xCollision = box1.right >= box2.left && box1.left <= box2.right
            const yCollision = box1.bottom + box1.velocity.y <= box2.top && box1.top >= box2.bottom
            const zCollision = box1.front >= box2.back && box1.back <= box2.front
        
            return xCollision && yCollision && zCollision
          }
        </code>
      </pre>

      <p>Here is all the code combined.</p>
    </section>

    <section>
      <h1>5. Creating the Player-Controlled Cube</h1>

      <pre>
        <code class="language-javascript">
          const cube = new Box({
            width: 1,
            height: 1,
            depth: 1,
            velocity: {
              x: 0,
              y: -0.01,
              z: 0
            }
          })
          cube.castShadow = true
          scene.add(cube)
        </code>
      </pre>

      <p>After creating the game enviornment, we can finally create the player controlled cube! This segment of code here defines the dimensions of the player's cube, gives it gravity and shadows, and then adds it onto the scene. <br><br>But don't we need a platform for our cube to rest on?</p>
    </section>

    <section>
      <h1>6. Creating the Ground</h1>

      <pre>
        <code class="language-javascript">
          const ground = new Box({
            width: 7,
            height: 0.5,
            depth: 20,
            color: '#155e75',
            position: {
              x: 0,
              y: -2,
              z: -9
            }
          })
          ground.receiveShadow = true
          scene.add(ground)
        </code>
      </pre>

      <p>This code creates the platform for our game! Once again, we define the dimensions and position of the platform, and add it to the scene. <br><br>This is how our scene looks like now!</p>
      <img src="Images/threejs-no-enemies.png" alt="">
      <p>Let's now focus on getting the cube to move!</p>
    </section>

    <section>
      <h1>7. Controlling the Cube's movement</h1>

      <pre>
        <code class="language-javascript">
          const keys = {
            w: {
              pressed: false
            },
            a: {
              pressed: false
            },
            s: {
              pressed: false
            },
            d: {
              pressed: false
            }
          };

          let isTouchingGround = false;
        </code>
      </pre>

      <p>We must first create an Object to track whether certain keys <code class="language-js">(W, A, S, D)</code> are currently pressed. Additionally, <code class="language-js">isTouchingGround</code> tracks whether the cube is currently in contact with the ground.</p>

      <pre>
        <code class="language-javascript">
          window.addEventListener('keydown', (event) => {
            switch(event.code) {
              case 'KeyA':
                keys.a.pressed = true;
                break;
          
              case 'KeyD':
                keys.d.pressed = true;
                break;
          
              case 'KeyW':
                keys.w.pressed = true;
                break;
          
              case 'KeyS':
                keys.s.pressed = true;
                break;
          
              case 'Space':
                if (isTouchingGround === true) {
                  cube.velocity.y = 0.2;
                }
                break;
            }
          });          
        </code>
      </pre>      

      <p>With our keypress-tracking Object setup, we can now add an event listener to detect when keys are pressed down. However, our cube does not actually move yet (aside from jumping), as that will be handled at a later point in time.</p>

      <pre>
        <code class="language-javascript">
          window.addEventListener('keyup', (event) => {
            switch(event.code) {
              case 'KeyA':
                keys.a.pressed = false;
                break;
          
              case 'KeyD':
                keys.d.pressed = false;
                break;
          
              case 'KeyW':
                keys.w.pressed = false;
                break;
          
              case 'KeyS':
                keys.s.pressed = false;
                break;
            }
          });                
        </code>
      </pre>   

      <p>Conversely, we must also add an event listener to detect when keys are released.</p>
    </section>

    <section>
      <h1>7. The Animation Loop</h1>

      <pre>
        <code class="language-javascript">
          function animate() {
            const animationId = requestAnimationFrame(animate);
            renderer.render(scene, camera);          
        </code>
      </pre>

      <p>The <code class="language-javascript">animate()</code> function is the main animation loop. It updates the scene continuously, rendering each new frame and updating all objects' states.</p>
 
      <pre>
        <code class="language-javascript">
          const movementSpeed = 0.1;
          cube.velocity.x = 0;
          cube.velocity.z = 0;
        
          // Z-axis
          if (keys.w.pressed) {
            cube.velocity.z = -movementSpeed;
          } else if (keys.s.pressed) {
            cube.velocity.z = movementSpeed;
          }
        
          // X-axis
          if (keys.a.pressed) {
            cube.velocity.x = -movementSpeed;
          } else if (keys.d.pressed) {
            cube.velocity.x = movementSpeed;
          }
        
          cube.update(ground);
        </code>
      </pre>

      <p>Within <code class="language-javascript">animate()</code>, cube movement is handled. <code class="language-javascript">cube.update(ground)</code> updates the cube's position based on its current velocity and checks for collisions with the ground.</p>
   
      <pre>
        <code class="language-javascript">
          if (frames % spawnRate === 0) {
            if (spawnRate > 10) {spawnRate -= 19}
        
            const rand = (Math.random() * 7) - 3.5;
        
            const enemy = new Box({
              width: 1,
              height: 1,
              depth: 1,
              position: {
                x: rand,
                y: 0,
                z: -20
              },
              velocity: {
                x: 0,
                y: -0.01,
                z: 0.05
              },
              color: 'red',
              zAcceleration: true
            });
            enemy.castShadow = true;
            scene.add(enemy);
        
            enemies.push(enemy);
          }
        
          frames++;
        }              
        </code>
      </pre>
      
      <p>This code segment is responsible for spawning enemies into the platform. It defines the properties of the enemy, such as its dimensions and colours, before adding it to the scene. <br><br>The enemy spawnrate is also defined here. <code class="language-js">if (spawnRate > 10) {spawnRate -= 19}</code> spawns more enemies the more time elapses, making the game progressively harder.</p>

      <pre>
        <code class="language-javascript">
          enemies.forEach(enemy => {
            enemy.update(ground);
            if (boxCollision({box1: cube, box2: enemy}) || cube.position.y < -10) {
              cancelAnimationFrame(animationId);
              document.querySelector('.end-screen-wrapper').style.display = 'contents';
              document.querySelector('.end-background').classList.add('animation-end-background');
              document.querySelector('.filter').classList.add('animation-filter');
              document.querySelector('#display').textContent = `You were alive for ${seconds / 100}s!`;
        
              document.querySelector('button').addEventListener('click', () => {
                location.reload();
              });
            }
          });                   
        </code>
      </pre>

      <p>This part of the code handles the enemy's interactions with the Player-Controlled box and the ground. <br><br>When the player's box collides with an enemy box or falls off the platform, an End Screen will then be displayed. <br><br>It looks like this:</p>
      <img src="Images/threejs-end-screen.png" alt="">

      <pre>
        <code class="language-javascript">
          const enemies = []
          let frames = 0
          let spawnRate = 200
        
          let seconds = 0
          setInterval(() =>{
            seconds ++
          }, 10)               
        </code>
      </pre>

      <p>Finally, these variables must be initialised outside the loop, as they keep track of the number of enemies, the spawnrate, and the time elapsed since starting. <br><br>Here is the <code class="language-javascript">animate()</code> function as a whole:</p>
      
      <pre>
        <code class="language-javascript">
          const enemies = []
          let frames = 0
          let spawnRate = 200
        
          let seconds = 0
          setInterval(() =>{
            seconds ++
          }, 10)
        
          function animate() {
            const animationId = requestAnimationFrame(animate)
            renderer.render(scene, camera)
        
            const movementSpeed = 0.1
            cube.velocity.x = 0
            cube.velocity.z = 0
        
            //z-axis
            if (keys.w.pressed) {
              cube.velocity.z = -movementSpeed
            }
        
            else if (keys.s.pressed) {
              cube.velocity.z = movementSpeed
            }
        
            //x-axis
            if (keys.a.pressed) {
              cube.velocity.x = -movementSpeed
            }
        
            else if (keys.d.pressed) {
              cube.velocity.x = movementSpeed
            }
        
            if (frames % spawnRate === 0) {
              if (spawnRate > 10) spawnRate  -= 19
        
              const rand = (Math.random() * 7) - 3.5
        
              const enemy = new Box({
                width: 1,
                height: 1,
                depth: 1,
                position: {
                  x: rand,
                  y: 0,
                  z: -20
                },
                velocity: {
                  x: 0,
                  y: -0.01,
                  z: 0.05
                },
                color: 'red',
                zAcceleration: true
              })
              enemy.castShadow = true
              scene.add(enemy)
        
              enemies.push(enemy)
            }
        
            frames ++
        
            cube.update(ground)
            enemies.forEach(enemy => {
              enemy.update(ground)
              if (boxCollision({box1: cube, box2: enemy}) || cube.position.y < -10) {
                console.log('fail')
                cancelAnimationFrame(animationId)
                document.querySelector('.end-screen-wrapper').style.display = 'contents';
                document.querySelector('.end-background').classList.add('animation-end-background')
                document.querySelector('.filter').classList.add('animation-filter')
                document.querySelector('#display').textContent = `You were alive for ${seconds / 100}s!`
        
                document.querySelector('button').addEventListener('click', () => {
                  location.reload();
                });
              }})
          }
          animate()           
        </code>
      </pre>

    </section>

    <section>
      <h1>Conclusion</h1>

      <p>And with that, the game is complete! Here is the <a href="https://higherground189.github.io/Three.JS-EndlessRunner/">link</a> to try it out!</p>
      <img src="Images/threejs-runner-example-gif.gif" alt="">
      <p>Overall, this project managed to familiarise me with the capabilites of Three.js. With it, I managed to create a fun game that I can enjoy playing. I definitely feel much more confident in creating 3D graphics on websites now, and will not hesitate if I get the opportunity in the future!</p>
    </section>

  </main>

  <footer>

    <section class="section-wrapper">
      <div class="section-name">
        <img src="Images/address-icon.svg" alt="" class="logo-img">
          Ying Ray
      </div>

      <div class="links">
        <a href="index.html">Home</a>
        <a href="projects.html">Projects</a>
        <a href="about_me.html">About me</a>
        <a href="">Resume</a>
      </div>
    </section>

    <section class="section-wrapper">
      <div class="section-name">
        Contact Me
      </div>

      <div class="links">
        <a href="mailto: yingray88@gmail.com">Email</a>
        <a href="https://www.linkedin.com/in/y-r-lee-627b2b322/">LinkedIn</a>
        <a href="https://github.com/HigherGround189">GitHub</a>
      </div>
    </section>


  </footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>
